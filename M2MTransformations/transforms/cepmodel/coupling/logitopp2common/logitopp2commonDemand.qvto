library logitopp2commonDemand;

import logitopp2commonUtil;
import logitopp2commonNetwork;

modeltype COMMON_MM uses CommonFreightTransportMetamodel('http://www.cep-model-coupling.com/commonFreightTransportMetamodel');
modeltype LOGITOPP uses logiToppMetamodel('http://www.cep-model-coupling.com/logiToppMetamodel');

mapping LOGITOPP::Demand::demand2Demand(logisticNetwork : COMMON_MM::logisticNetwork::LogisticNetwork) : COMMON_MM::logisticDemand::Demand {
	shipments += self.parcels -> map parcel2Shipment(logisticNetwork);
}

// assumption: no inside - inside shipments
mapping LOGITOPP::logiTopp::parcels::Parcel::parcel2Shipment(logisticNetwork : COMMON_MM::logisticNetwork::LogisticNetwork) : COMMON_MM::logisticDemand::Shipment
disjuncts
	LOGITOPP::logiTopp::parcels::PrivateParcel::privateParcel2OutsideToInsideShipment,
	LOGITOPP::logiTopp::parcels::BusinessParcel::businessParcel2OutsideToInsideShipment,
	LOGITOPP::logiTopp::parcels::BusinessParcel::businessParcel2InsideToOutsideShipment
{}

// TODO: discuss
mapping LOGITOPP::logiTopp::parcels::PrivateParcel::privateParcel2OutsideToInsideShipment(logisticNetwork : COMMON_MM::logisticNetwork::LogisticNetwork) : COMMON_MM::logisticDemand::OutsideToInsideShipment 
when {self.oclIsKindOf(LOGITOPP::logiTopp::parcels::PrivateParcel)}
{
	id := self.id.toString();
	responsibleCEPSP := self.responsibleCEPSP.resolveone(COMMON_MM::logisticNetwork::CEPSP);
	size := size2Volume(self.shipmentSize);
	
	var receiverPerson := self.consumer.resolveone(COMMON_MM::localEntities::Person);
	receiver := receiverPerson;
	destination := determineDestination(self, receiverPerson, logisticNetwork);
	
	arrivalAtOriginDepot := new COMMON_MM::utils::MultiDayTimestamp(self.plannedArrivalDate);
	arrivalAtDestinationTimeWindow := createWholeSimulationPeriodTimeWindow();
}


mapping LOGITOPP::logiTopp::parcels::BusinessParcel::businessParcel2OutsideToInsideShipment(logisticNetwork : COMMON_MM::logisticNetwork::LogisticNetwork) : COMMON_MM::logisticDemand::OutsideToInsideShipment 
when {self.oclIsKindOf(LOGITOPP::logiTopp::parcels::BusinessParcel) and not self.isPickup} {
	id := self.id.toString();
	responsibleCEPSP := self.responsibleCEPSP.resolveone(COMMON_MM::logisticNetwork::CEPSP);
	size := size2Volume(self.shipmentSize);
	
	var receiverBranch := self.consumer.resolveone(COMMON_MM::localEntities::Business).branches -> first();
	receiver := receiverBranch;
	destination := receiverBranch.location;
		
	arrivalAtOriginDepot := new COMMON_MM::utils::MultiDayTimestamp(self.plannedArrivalDate);
	arrivalAtDestinationTimeWindow := createWholeSimulationPeriodTimeWindow();
}

mapping LOGITOPP::logiTopp::parcels::BusinessParcel::businessParcel2InsideToOutsideShipment(logisticNetwork : COMMON_MM::logisticNetwork::LogisticNetwork) : COMMON_MM::logisticDemand::InsideToOutsideShipment 
when {self.oclIsKindOf(LOGITOPP::logiTopp::parcels::BusinessParcel) and self.isPickup} {
	id := self.id.toString();
	responsibleCEPSP := self.responsibleCEPSP.resolveone(COMMON_MM::logisticNetwork::CEPSP);
	size := size2Volume(self.shipmentSize);
	
	var producerBranch := self.producer.resolveone(COMMON_MM::localEntities::Business).branches -> first();
	producer := producerBranch;
	origin := producerBranch.location;
	
	arrivalAtOrigin := new COMMON_MM::utils::MultiDayTimestamp(self.plannedArrivalDate);
	arrivalAtDepotTimeWindow := createWholeSimulationPeriodTimeWindow();
}

helper determineDestination(privateParcel : LOGITOPP::logiTopp::parcels::PrivateParcel, receiver : COMMON_MM::localEntities::Person, logisticNetwork : COMMON_MM::logisticNetwork::LogisticNetwork) : COMMON_MM::network::Location_ {
	switch {
		case (privateParcel.destinationType = LOGITOPP::logiTopp::parcels::ParcelDestinationType::HOME) {
			return receiver.household.location
		}
		case (privateParcel.destinationType = LOGITOPP::logiTopp::parcels::ParcelDestinationType::WORK) {
			// TODO: handle case: add work location?
			return null;
		}
		case (privateParcel.destinationType = LOGITOPP::logiTopp::parcels::ParcelDestinationType::PACK_STATION) {
			var location := privateParcel.zoneAndLocation.location.map location2Location();
			var packstation := logisticNetwork.publicServicePoints -> select(ps | areEqualLocations(ps.location, location)) -> first();
			return packstation.location;
		}
		else return null;	
	};
	return null;
}