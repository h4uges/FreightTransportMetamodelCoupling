modeltype COMMON_MM uses CommonFreightTransportMetamodel('http://www.cep-model-coupling.com/commonFreightTransportMetamodel');
modeltype LOGITOPP uses logiToppMetamodel('http://www.cep-model-coupling.com/logiToppMetamodel');

transformation logitopp2common(in logiToppModel: LOGITOPP, out commonModel : COMMON_MM);

property locationIdCounter = 0;
property tourIdCounter = 0;
property packStationRepresentatives: Set(LOGITOPP::mobiTopp::network::Location);
property hubRepresentatives: Set(LOGITOPP::mobiTopp::network::Location);
property vehicleDepotReprensentatives: Set(LOGITOPP::mobiTopp::network::Location); 
property logiToppDemand : LOGITOPP::Demand;

main() {
	var logiToppRoot := logiToppModel.objectsOfType(LOGITOPP::SolutionExchangeRoot) -> asSequence() -> first();
	
	// init
	logiToppDemand := logiToppRoot.demand;
	packStationRepresentatives += findRepresentativeLocations(logiToppRoot.demand);
	
	// network
	var commonNetwork := logiToppRoot.network.map roadNetwork2Network();
	
	// population
	var commonPopulation := logiToppRoot._population.map population2Population(); 
	
	// logisticNetwork
	var commonLogisticNetwork := logiToppRoot.transportNetwork.map transportInfrastructure2LogisticNetwork();
	
	// demand
	var commonDemand := logiToppRoot.demand.map demand2Demand();
	
	// solution
	
}

// ---- network ----

mapping LOGITOPP::mobiTopp::network::RoadNetwork::roadNetwork2Network() : COMMON_MM::network::Network {
	nodes += self.nodes -> map node2Node();
	edges += self.edges -> map edge2Edge();
	// skip: zones
}

mapping LOGITOPP::mobiTopp::network::Node::node2Node() : COMMON_MM::network::Node {
	id := self.id.toString();
	coordinate := self.coord.map point2D2Coordinate();
}

mapping LOGITOPP::mobiTopp::network::Point2D::point2D2Coordinate() : COMMON_MM::utils::Coordinate {
	x := self.x;
	y := self.y;
}

mapping LOGITOPP::mobiTopp::network::Edge::edge2Edge() : COMMON_MM::network::Edge {
	_from := self._from.resolveone(COMMON_MM::network::Node);
	to := self.to.resolveone(COMMON_MM::network::Node);
	length := self.length;
	allowedVehicleTypes; // TODO: add to model?
}

// ---- network.location ----

mapping LOGITOPP::mobiTopp::network::Location::location2Location() : COMMON_MM::network::Location_ {
	id := createLocationId();
	coordinate := self.coordinate.map point2D2Coordinate();
	networkAccess := new COMMON_MM::network::EdgeBasedNetworkAccess(self.roadAccessEdge, self.roadPosition);
}

helper createLocationId() : String {
	var id = "loc_" + locationIdCounter.toString();
	locationIdCounter := locationIdCounter + 1;
	return id;
}

constructor COMMON_MM::network::EdgeBasedNetworkAccess::EdgeBasedNetworkAccess(edge_ : LOGITOPP::mobiTopp::network::Edge, edgePostion_ : Real) {
	edge := edge_.resolveone(COMMON_MM::network::Edge);
	edgePosition := edgePostion_;
}

// ---- population ----

mapping LOGITOPP::Population::population2Population() : COMMON_MM::localEntities::Population {
	households += self.households -> map household2Household();
	businesses;
}

mapping LOGITOPP::mobiTopp::citizens::Household::household2Household() : COMMON_MM::localEntities::Household {
	id := self.id.toString();
	member += self.members -> map person2Person();
	location := self.location.map location2Location();
}

mapping LOGITOPP::mobiTopp::citizens::Person::person2Person() : COMMON_MM::localEntities::Person {
	id := self.id.toString();
}

mapping LOGITOPP::logiTopp::business::Business::business2Business() : COMMON_MM::localEntities::Business {
	id := self.id.toString();
	branches += new COMMON_MM::localEntities::BusinessBranch(self);
}

constructor COMMON_MM::localEntities::BusinessBranch::BusinessBranch(business : LOGITOPP::logiTopp::business::Business) {
	id := "branch_" + business.id.toString();
	location := business.location.map location2Location();
	openingHours += business.openingHours -> map openingHour2OpeningHour();
}

// TODO: review
mapping LOGITOPP::logiTopp::business::OpeningHour::openingHour2OpeningHour() : COMMON_MM::utils::MultiDayTimeWindow {
	_from := new COMMON_MM::utils::MultiDayTimestamp(self.dayOfWeek, self.start);
	to := new COMMON_MM::utils::MultiDayTimestamp(self.dayOfWeek, self._end)
}

// ---- logistic Network ----

mapping LOGITOPP::TransportInfrastructure::transportInfrastructure2LogisticNetwork() : COMMON_MM::logisticNetwork::LogisticNetwork {
	publicServicePoints := packStationRepresentatives -> collect(loc | new COMMON_MM::logisticNetwork::Packstation(loc));
	
	CEPSPs += self.cepServiceProviders -> map cepsp2CEPSP(publicServicePoints);
}

mapping LOGITOPP::logiTopp::distribution::CEPServiceProvider::cepsp2CEPSP(publicServicePoints : Collection(COMMON_MM::logisticNetwork::PublicServicePoint)) : COMMON_MM::logisticNetwork::CEPSP {
	id := self.id.toString();
	name := self.name.toString();
	
	vehicleDepots := self.distributionCenters -> map distributionCenter2VehicleDepot();
	logisticHubs := self.distributionCenters -> map distributionCenter2LogisticHub();
	
	var allUsedPackstationLocations := findAllPackstationLocationsForCEPSP(logiToppDemand, self);
	var allUniqueUsedPackstationLocations := 
		allUsedPackstationLocations 
		-> collect(loc | getRepresentativeLocation(loc, packStationRepresentatives).resolveone(COMMON_MM::network::Location_))
		-> asSet();
	var allUsedPublicServicePoints = publicServicePoints -> select(sp | allUniqueUsedPackstationLocations->includes(sp.location));
	
	usedPublicServicePoints += allUsedPublicServicePoints -> collect(sp | new COMMON_MM::logisticNetwork::UsedPublicServicePoint(sp));
	
	deliveryPartners += self.distributionCenters -> collect(dc | dc.regionalStructure.relatedDeliveryHubs -> collect(hub | hub.CEPSP)) -> flatten() -> asSet() -> late resolveone(COMMON_MM::logisticNetwork::CEPSP);
	pickUpPartners += self.distributionCenters -> collect(dc | dc.regionalStructure.relatedPickUpHubs -> collect(hub | hub.CEPSP)) -> flatten() -> asSet() -> late resolveone(COMMON_MM::logisticNetwork::CEPSP);
}

mapping LOGITOPP::logiTopp::distribution::DistributionCenter::distributionCenter2VehicleDepot() : COMMON_MM::logisticNetwork::VehicleDepot {
	id := "depot_" + self.id.toString();
	vehicleDepotReprensentatives += self.location;
	location := self.location.map location2Location();
	
	operationHours := createWholeSimulationPeriodTimeWindow();
	
	vehicles += self.fleet.deliveryVehicles -> map deliveryVehicle2Vehicle();
}

mapping LOGITOPP::logiTopp::distribution::fleet::DeliveryVehicle::deliveryVehicle2Vehicle() : COMMON_MM::logisticNetwork::Vehicle {
	id := self.id.toString();
	storageCapacity := new COMMON_MM::utils::FiniteVolumeDimension(self.capacity);
	operationHours += createVehicleOperationHours(self.earliestStartTime, self.latestEndTime);
	type := mapVehicleType(self.vehicleType);
}

helper createVehicleOperationHours(earliestStartTime : LOGITOPP::base::Time, latestEndTime : LOGITOPP::base::Time): Collection(COMMON_MM::utils::MultiDayTimeWindow){
	var operationHours : Sequence(COMMON_MM::utils::MultiDayTimeWindow) := Sequence {};
	var weekdays := Sequence { 0, 1, 2, 3, 4, 5, 6};
	
	weekdays -> forEach (weekday) {
		operationHours += new COMMON_MM::utils::MultiDayTimeWindow(new COMMON_MM::utils::MultiDayTimestamp(weekday, earliestStartTime), new COMMON_MM::utils::MultiDayTimestamp(weekday, latestEndTime))
	};
	
	return operationHours;
}

helper mapVehicleType(logiToppVehicleType : LOGITOPP::logiTopp::distribution::fleet::VehicleType) : COMMON_MM::network::VehicleType_ {
	switch {
		case (logiToppVehicleType = LOGITOPP::logiTopp::distribution::fleet::VehicleType::BIKE) {return COMMON_MM::network::VehicleType_::BIKE;}
		case (logiToppVehicleType = LOGITOPP::logiTopp::distribution::fleet::VehicleType::TRUCK) {return COMMON_MM::network::VehicleType_::TRUCK;}
		case (logiToppVehicleType = LOGITOPP::logiTopp::distribution::fleet::VehicleType::TRAM) {return COMMON_MM::network::VehicleType_::TRAM;}
		case (logiToppVehicleType = LOGITOPP::logiTopp::distribution::fleet::VehicleType::OTHERS) {return COMMON_MM::network::VehicleType_::OTHER;}
		else {return null;}
	};
}

mapping LOGITOPP::logiTopp::distribution::DistributionCenter::distributionCenter2LogisticHub() : COMMON_MM::logisticNetwork::LogisticHub {
	id := "hub_" + self.id.toString();
	hubRepresentatives += self.location;
	location := self.location.map location2Location();
	
	storageCapacity := new COMMON_MM::utils::InfiniteVolumeDimension();
	operationHours := createWholeSimulationPeriodTimeWindow();
	acceptedVehicleTypes := createAllVehicleTypes();
	
	// TODO: default values
	minimumTranshipmentTime := new COMMON_MM::utils::Durration_(0, 0, 0, 0);
	isExit := true;
	isEntry := true;
}

// ---- logisticNetwork.publicServicePoints ----

constructor COMMON_MM::logisticNetwork::UsedPublicServicePoint::UsedPublicServicePoint(publicServicePoint_ : COMMON_MM::logisticNetwork::PublicServicePoint) {
	grantedStorageCapacity := new COMMON_MM::utils::InfiniteVolumeDimension();
	publicServicePoint := publicServicePoint_;
}

constructor COMMON_MM::logisticNetwork::Packstation::Packstation(location_ : LOGITOPP::mobiTopp::network::Location) {
	location := location_.map location2Location();
	storageCapacity := new COMMON_MM::utils::InfiniteVolumeDimension();
}

query findAllPackstationLocationsForCEPSP(demand : LOGITOPP::Demand, cepsp : LOGITOPP::logiTopp::distribution::CEPServiceProvider) : Collection(LOGITOPP::mobiTopp::network::Location) {
	var packstationLocatons := 
		demand.parcels
		-> selectByKind(LOGITOPP::logiTopp::parcels::PrivateParcel)
		-> select(p | p.destinationType = LOGITOPP::logiTopp::parcels::ParcelDestinationType::PACK_STATION)
		-> select(p | p.responsibleCEPSP = cepsp)
		-> collect(p | p.zoneAndLocation.location)
		-> asSet();
	
	return packstationLocatons;
}

helper areEqual(a : LOGITOPP::mobiTopp::network::Location, b : LOGITOPP::mobiTopp::network::Location) : Boolean {
	return a.coordinate.x = b.coordinate.x and
  	a.coordinate.y = b.coordinate.y and
  	a.roadPosition = b.roadPosition and
  	a.roadAccessEdge = b.roadAccessEdge;
}

helper getRepresentativeLocation(element : LOGITOPP::mobiTopp::network::Location, representatives : Set(LOGITOPP::mobiTopp::network::Location)) : LOGITOPP::mobiTopp::network::Location {
  return representatives -> any(r | areEqual(element, r));
}

helper findRepresentativeLocations(demand : LOGITOPP::Demand) :Set(LOGITOPP::mobiTopp::network::Location) {
	var packstationLocatons := 
		demand.parcels 
		-> selectByKind(LOGITOPP::logiTopp::parcels::PrivateParcel)
		-> select(p | p.destinationType = LOGITOPP::logiTopp::parcels::ParcelDestinationType::PACK_STATION)
		-> collect(p | p.zoneAndLocation.location)
		-> asSet();
		
  	var representativeLocations : Set(LOGITOPP::mobiTopp::network::Location) = Set{};
	
	packstationLocatons -> forEach(loc) {
		var representativeFound : Boolean = false;
	
	    representativeLocations -> forEach(rep) {
	    	if (areEqual(loc, rep)) {
	        	representativeFound := true;
	      	}
	      	endif;
	    };
	
	    if (not representativeFound) {
	      	representativeLocations := representativeLocations -> including(loc);
	    }
	    endif;
	  };
	
	  return representativeLocations;
}

// ---- demand ----

mapping LOGITOPP::Demand::demand2Demand() : COMMON_MM::logisticDemand::Demand {
	shipments += self.parcels -> map parcel2Shipment();
}

// assumption: no inside - inside shipments
mapping LOGITOPP::logiTopp::parcels::Parcel::parcel2Shipment() : COMMON_MM::logisticDemand::Shipment
disjuncts
	LOGITOPP::logiTopp::parcels::PrivateParcel::privateParcel2OutsideToInsideShipment,
	LOGITOPP::logiTopp::parcels::BusinessParcel::businessParcel2OutsideToInsideShipment,
	LOGITOPP::logiTopp::parcels::BusinessParcel::businessParcel2InsideToOutsideShipment
{}

// TODO: discuss
mapping LOGITOPP::logiTopp::parcels::PrivateParcel::privateParcel2OutsideToInsideShipment() : COMMON_MM::logisticDemand::OutsideToInsideShipment 
when {self.oclIsKindOf(LOGITOPP::logiTopp::parcels::PrivateParcel)}
{
	id := self.id.toString();
	responsibleCEPSP := self.responsibleCEPSP.resolveone(COMMON_MM::logisticNetwork::CEPSP);
	size := size2Volume(self.shipmentSize);
	
	var receiverPerson := self.consumer.resolveone(COMMON_MM::localEntities::Person);
	receiver := receiverPerson;
	destination := determineDestination(self, receiverPerson);
	
	arrivalAtOriginDepot := new COMMON_MM::utils::MultiDayTimestamp(self.plannedArrivalDate);
	arrivalAtDestinationTimeWindow := createWholeSimulationPeriodTimeWindow();
}


mapping LOGITOPP::logiTopp::parcels::BusinessParcel::businessParcel2OutsideToInsideShipment() : COMMON_MM::logisticDemand::OutsideToInsideShipment 
when {self.oclIsKindOf(LOGITOPP::logiTopp::parcels::BusinessParcel) and not self.isPickup} {
	id := self.id.toString();
	responsibleCEPSP := self.responsibleCEPSP.resolveone(COMMON_MM::logisticNetwork::CEPSP);
	size := size2Volume(self.shipmentSize);
	
	var receiverBranch := self.consumer.resolveone(COMMON_MM::localEntities::Business).branches -> first();
	receiver := receiverBranch;
	destination := receiverBranch.location;
		
	arrivalAtOriginDepot := new COMMON_MM::utils::MultiDayTimestamp(self.plannedArrivalDate);
	arrivalAtDestinationTimeWindow := createWholeSimulationPeriodTimeWindow();
}

mapping LOGITOPP::logiTopp::parcels::BusinessParcel::businessParcel2InsideToOutsideShipment() : COMMON_MM::logisticDemand::InsideToOutsideShipment 
when {self.oclIsKindOf(LOGITOPP::logiTopp::parcels::BusinessParcel) and self.isPickup} {
	id := self.id.toString();
	responsibleCEPSP := self.responsibleCEPSP.resolveone(COMMON_MM::logisticNetwork::CEPSP);
	size := size2Volume(self.shipmentSize);
	
	var producerBranch := self.producer.resolveone(COMMON_MM::localEntities::Business).branches -> first();
	producer := producerBranch;
	origin := producerBranch.location;
	
	arrivalAtOrigin := new COMMON_MM::utils::MultiDayTimestamp(self.plannedArrivalDate);
	arrivalAtDepotTimeWindow := createWholeSimulationPeriodTimeWindow();
}

helper determineDestination(privateParcel : LOGITOPP::logiTopp::parcels::PrivateParcel, receiver : COMMON_MM::localEntities::Person) : COMMON_MM::network::Location_ {
	switch {
		case (privateParcel.destinationType = LOGITOPP::logiTopp::parcels::ParcelDestinationType::HOME) {
			return receiver.household.location
		}
		case (privateParcel.destinationType = LOGITOPP::logiTopp::parcels::ParcelDestinationType::WORK) {
			// TODO: handle case: add work location?
			return null;
		}
		case (privateParcel.destinationType = LOGITOPP::logiTopp::parcels::ParcelDestinationType::PACK_STATION) {
			return getRepresentativeLocation(privateParcel.zoneAndLocation.location, packStationRepresentatives).resolveone(COMMON_MM::network::Location_);
		}
		else return null;	
	};
}

// TODO: discuss
helper size2Volume(parcelSize : LOGITOPP::logiTopp::parcels::ShipmentSize) : COMMON_MM::utils::FiniteVolumeDimension {
	switch {
		case (parcelSize = LOGITOPP::logiTopp::parcels::ShipmentSize::SMALL) {return new COMMON_MM::utils::FiniteVolumeDimension(420 + (18240 - 420).div(2));}
		case (parcelSize = LOGITOPP::logiTopp::parcels::ShipmentSize::MEDIUM) {return new COMMON_MM::utils::FiniteVolumeDimension(18240 + (38760 - 18240).div(2));}
		case (parcelSize = LOGITOPP::logiTopp::parcels::ShipmentSize::LARGE) {return new COMMON_MM::utils::FiniteVolumeDimension(38760 + (82080 - 38760).div(2));}
		case (parcelSize = LOGITOPP::logiTopp::parcels::ShipmentSize::EXTRA_LARGE) {return new COMMON_MM::utils::FiniteVolumeDimension(820080 + (171000 - 820080).div(2));}
		case (parcelSize = LOGITOPP::logiTopp::parcels::ShipmentSize::PALLET) {return new COMMON_MM::utils::FiniteVolumeDimension(0);}
		case (parcelSize = LOGITOPP::logiTopp::parcels::ShipmentSize::CONTAINER) {return new COMMON_MM::utils::FiniteVolumeDimension(0);}
		else return null;
	};
}


// ---- solution ----

mapping LOGITOPP::Solution::solution2Solution() : COMMON_MM::logisticSolution::LogisticSolution {
	tours += self.plannedTours -> map plannedTour2PlannedTour();
	// TODO
	shipmentRecords;
}

// ---- solution.tours ----

mapping LOGITOPP::logiTopp::distribution::tours::PlannedDeliveryTour::plannedTour2PlannedTour() : COMMON_MM::logisticSolution::PlannedTour {
	id := createTourId();
	executingCEPSP := self.executingCEPSP.resolveone(COMMON_MM::logisticNetwork::CEPSP);
	vehicle := self.stops -> first().vehicle.resolveone(COMMON_MM::logisticNetwork::Vehicle);
	
	var intermediateStops := self.stops -> map parcelActivity2PickUpDeliveryStop(id);
	stops += intermediateStops;
	var orgFirstStop := intermediateStops -> first();
	var orgLastStop := intermediateStops -> last();
	
	var firstStop := new COMMON_MM::logisticSolution::StartEndStop(id, orgFirstStop.no - 1, vehicle.depot, orgFirstStop.stopTimeWindow.oclAsType(COMMON_MM::utils::MultiDayTimeWindow));
	var lastStop := new COMMON_MM::logisticSolution::StartEndStop(id, orgFirstStop.no + 1, vehicle.depot, orgFirstStop.stopTimeWindow.oclAsType(COMMON_MM::utils::MultiDayTimeWindow));
	stops -> prepend(firstStop);
	stops += lastStop;
}

helper createTourId() : String {
	var id = "tour_" + tourIdCounter.toString();
	locationIdCounter := tourIdCounter + 1;
	return id;
}

mapping LOGITOPP::logiTopp::distribution::delivery::ParcelActivity::parcelActivity2PickUpDeliveryStop(tourId : String) : COMMON_MM::logisticSolution::PickUpDeliveryStop 
disjuncts LOGITOPP::logiTopp::distribution::delivery::ParcelActivity::parcelActivity2LogisticFacilityStop,
LOGITOPP::logiTopp::distribution::delivery::ParcelActivity::parcelActivity2NormalStop
{}

mapping LOGITOPP::logiTopp::distribution::delivery::ParcelActivity::parcelActivity2LogisticFacilityStop(tourId : String) : COMMON_MM::logisticSolution::LogisticFacilityStop
when {
	findLogisticFacility(self.stopLocation.location) <> null
}{
	logisticFacility := findLogisticFacility(self.stopLocation.location);
	
	no := self.no; // correct?
	id := tourId + "_" + no.toString();
	
	stopLocation := null;
	if(logisticFacility.oclIsKindOf(COMMON_MM::logisticNetwork::Packstation)) {
		stopLocation := new COMMON_MM::logisticSolution::ReferenceStopLocation(logisticFacility.oclAsType(COMMON_MM::logisticNetwork::Packstation).location)
	} endif;
	if(logisticFacility.oclIsKindOf(COMMON_MM::logisticNetwork::LogisticHub)) {
		stopLocation := new COMMON_MM::logisticSolution::ReferenceStopLocation(logisticFacility.oclAsType(COMMON_MM::logisticNetwork::LogisticHub).location)
	} endif;
	
	stopTimeWindow := createStopTimeWindow(self.plannedTime, self.deliveryDuration);
	
	unloadedShipments +=  self.parcels -> collect(parcel | parcel.resolveone(COMMON_MM::logisticDemand::Shipment));
	loadedShipments +=  self.pickUps -> collect(parcel | parcel.resolveone(COMMON_MM::logisticDemand::Shipment));
}

mapping LOGITOPP::logiTopp::distribution::delivery::ParcelActivity::parcelActivity2NormalStop(tourId : String) : COMMON_MM::logisticSolution::NormalStop when {
	findLogisticFacility(self.stopLocation.location) = null
}{
	no := self.no; // correct?
	id := tourId + "_" + no.toString();
	
	stopLocation := new COMMON_MM::logisticSolution::CustomStopLocation(self.stopLocation.location.map location2Location());
	stopTimeWindow := createStopTimeWindow(self.plannedTime, self.deliveryDuration);
	
	unloadedShipments +=  self.parcels -> collect(parcel | parcel.resolveone(COMMON_MM::logisticDemand::Shipment));
	loadedShipments +=  self.pickUps -> collect(parcel | parcel.resolveone(COMMON_MM::logisticDemand::Shipment));
}

query findLogisticFacility(location : LOGITOPP::mobiTopp::network::Location) : COMMON_MM::logisticNetwork::LogisticFacility {
	var foundPackstation := packStationRepresentatives -> any(psLoc | areEqual(psLoc, location));
	if (foundPackstation) {
		var packstationLocation := packStationRepresentatives -> select(psLoc | areEqual(psLoc, location)) -> asSequence() -> first();
		return packstationLocation.container().oclAsType(COMMON_MM::logisticNetwork::Packstation);
	} endif;
	
	var foundHub := hubRepresentatives -> any(hubLoc | areEqual(hubLoc, location));
	if (foundHub) {
		var hubLocation := hubRepresentatives -> select(hubLoc | areEqual(hubLoc, location)) -> asSequence() -> first();
		return hubLocation.container().oclAsType(COMMON_MM::logisticNetwork::LogisticHub);
	} endif;
	
	return null;
}

constructor COMMON_MM::logisticSolution::CustomStopLocation::CustomStopLocation(location_ : COMMON_MM::network::Location_) {
	location := location_;
}

constructor COMMON_MM::logisticSolution::ReferenceStopLocation::ReferenceStopLocation(location_ : COMMON_MM::network::Location_) {
	location := location_;
}

helper createStopTimeWindow(time : LOGITOPP::base::Time, minutes: Integer) : COMMON_MM::utils::MultiDayTimeWindow {
	var startTimeStamp := new COMMON_MM::utils::MultiDayTimestamp(time);
	var endTimeStamp := addMinutes(startTimeStamp.clone(), minutes);
	
	return new COMMON_MM::utils::MultiDayTimeWindow(startTimeStamp, endTimeStamp);
}

constructor COMMON_MM::logisticSolution::StartEndStop::StartEndStop(tourId : String, stopNo : Integer, depot_ : COMMON_MM::logisticNetwork::VehicleDepot, stopTimeWindow_ : COMMON_MM::utils::MultiDayTimeWindow) {
	id := tourId + "_" + no.toString();
	no := stopNo;
	depot := depot_;
	stopLocation := new COMMON_MM::logisticSolution::ReferenceStopLocation(depot.location);
	stopTimeWindow := stopTimeWindow_.clone();
}

// ---- solution.shipmentRecords ---- 

// ---- helper ----

helper createAllVehicleTypes() : Collection(COMMON_MM::network::VehicleType_) {
	var allVehicleTypes := Sequence {
		COMMON_MM::network::VehicleType_::TRUCK,
		COMMON_MM::network::VehicleType_::TRAM,
		COMMON_MM::network::VehicleType_::CAR,
		COMMON_MM::network::VehicleType_::BIKE,
		COMMON_MM::network::VehicleType_::WALKING,
		COMMON_MM::network::VehicleType_::DELIVERY_VEHICLE,
		COMMON_MM::network::VehicleType_::OTHER
	};
	return allVehicleTypes;
}

// ---- helper.time ----

// TODO: review
constructor COMMON_MM::utils::MultiDayTimestamp::MultiDayTimestamp(weekday : LOGITOPP::base::Weekday, time : LOGITOPP::base::Time) {
	simulationDay := weekdayToSimulationDay(weekday);
	hour := time.seconds.div(3600);
	minute := time.seconds.div(3600).mod(60); 
	second := time.seconds.mod(60);
}

helper createWholeSimulationPeriodTimeWindow() : COMMON_MM::utils::MultiDayTimeWindow {
	return new COMMON_MM::utils::MultiDayTimeWindow(null, null);
}

constructor COMMON_MM::utils::MultiDayTimeWindow::MultiDayTimeWindow(from_ : COMMON_MM::utils::MultiDayTimestamp, to_ : COMMON_MM::utils::MultiDayTimestamp) {
	_from := from_;
	to := to_;
}

constructor COMMON_MM::utils::MultiDayTimestamp::MultiDayTimestamp(simulationDay_ : Integer, hour_ : Integer, minute_ : Integer, second_ : Integer) {
	simulationDay := simulationDay_;
	hour := hour_;
	minute := minute_;
	second := second_;
}

constructor COMMON_MM::utils::MultiDayTimestamp::MultiDayTimestamp(simulationDay_ : Integer, timeWithinDay : LOGITOPP::base::Time) {
	simulationDay := simulationDay_;
	hour := timeWithinDay.seconds.div(60).div(60).mod(24);
	minute := timeWithinDay.seconds.div(60).mod(60); 
	second := timeWithinDay.seconds.mod(60);
}

constructor COMMON_MM::utils::MultiDayTimestamp::MultiDayTimestamp(timestamp : LOGITOPP::base::Time) {
	simulationDay := timestamp.seconds.div(24).div(60).div(60);
	hour := timestamp.seconds.div(60).div(60).mod(24);
	minute := timestamp.seconds.div(60).mod(60);
	second := timestamp.seconds.mod(60);
}

// TODO: review
helper weekdayToSimulationDay(weekday : LOGITOPP::base::Weekday) : Integer {
	switch {
		case (weekday = LOGITOPP::base::Weekday::MONDAY) {return 0};
		case (weekday = LOGITOPP::base::Weekday::TUESDAY) {return 1};
		case (weekday = LOGITOPP::base::Weekday::WEDNESDAY) {return 2};
		case (weekday = LOGITOPP::base::Weekday::THURSDAY) {return 3};
		case (weekday = LOGITOPP::base::Weekday::FRIDAY) {return 4};
		case (weekday = LOGITOPP::base::Weekday::SATURDAY) {return 5};
		case (weekday = LOGITOPP::base::Weekday::SUNDAY) {return 6};
		else {return -1;}
	}
}

constructor COMMON_MM::utils::Durration_::Durration_(days_ : Integer, hours_ : Integer, minutes_ : Integer, seconds_ : Integer) {
	days := days_;
	hours := hours_;
	minutes := minutes_;
	seconds := seconds_;
}

helper addMinutes(timeStamp : COMMON_MM::utils::MultiDayTimestamp, minutes : Integer) : COMMON_MM::utils::MultiDayTimestamp {
	var totalMinutes = timeStamp.minute + minutes;
    var additionalHours = totalMinutes.div(60);
    var remainingMinutes = totalMinutes.mod(60);
    var newHours = (timeStamp.hour + additionalHours).mod(24);
    var newDays = timeStamp.simulationDay + (timeStamp.simulationDay + additionalHours).div(24);
	
	return new COMMON_MM::utils::MultiDayTimestamp(newDays, newHours, remainingMinutes, timeStamp.second)
}

// ---- helper.capacity ----

constructor COMMON_MM::utils::InfiniteVolumeDimension::InfiniteVolumeDimension() {}

constructor COMMON_MM::utils::FiniteVolumeDimension::FiniteVolumeDimension(volumeCubicCentimeter : Real) {
	volumeCubicMetre := volumeCubicCentimeter / 10000000;
}